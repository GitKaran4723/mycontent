# **📘 Derived Operators in Relational Algebra**

---

## **🔹 Definition:**

Derived operators are those that can be expressed in terms of basic relational algebra operators such as Selection (σ), Projection (π), Union (∪), Set Difference (−), Cartesian Product (×), and Rename (ρ).

They are called “derived” because they are constructed from these fundamental operations to perform more complex data retrieval tasks.

### **🔸 Common Derived Operators:**

1. **Join Operators (⋈)**

2. **Division (÷)**

---

## **🔹 1\. Join Operators (⋈)**

### **🔸 Definition:**

A Join operation combines tuples from two or more relations based on a common attribute (or condition).  
 It is one of the most important operations in relational algebra since it allows related data stored in different tables to be combined meaningfully**.**

### **🔸 General Form:**  **R ⋈\_{condition} S**

###   where *R* and *S* are two relations, and *condition* specifies how tuples are to be matched.

---

### **🔸 Types of Joins:**

---

### **🟢 1\. Inner Join**

#### **🔸 Definition:**

The Inner Join retrieves only those tuples that satisfy the join condition — i.e., tuples with matching values in both relations.  
 If there is no match between the two tables, that row is excluded from the result.

#### **🔸 Notation:**  **R ⋈\_{condition} S** 

#### **🔸 Example:**

**EMPLOYEE**

| EmpID | Name | DeptID | Salary |
| ----- | ----- | ----- | ----- |
| 1 | Raj | D1 | 60000 |
| 2 | Neha | D2 | 55000 |
| 3 | Arjun | D3 | 45000 |

**DEPARTMENT**

| DeptID | DeptName |
| ----- | ----- |
| D1 | HR |
| D2 | IT |
| D4 | Finance |

**Relational Algebra Expression:**

 EMPLOYEE ⋈\_{EMPLOYEE.DeptID \= DEPARTMENT.DeptID} DEPARTMENT  
 

**Result:**

| EmpID | Name | DeptID | Salary | DeptName |
| ----- | ----- | ----- | ----- | ----- |
| 1 | Raj | D1 | 60000 | HR |
| 2 | Neha | D2 | 55000 | IT |

#### 

#### 

#### **🔸 SQL Equivalent:**

SELECT E.EmpID, E.Name, E.Salary, D.DeptName  
FROM EMPLOYEE E  
INNER JOIN DEPARTMENT D  
ON E.DeptID \= D.DeptID;

---

### **🟣 2\. Conditional Join**

#### **🔸 Definition:**

A Conditional Join is an inner join where the condition can include comparison operators such as `=`, `>`, `<`, `>=`, or `<=`.  
 It retrieves tuples that satisfy the given condition between the two relations.

#### **🔸 Example:**

Retrieve employees whose salary is greater than ₹50,000 and join with department details.

 EMPLOYEE ⋈\_{Salary \> 50000 \\text{ AND } EMPLOYEE.DeptID \= DEPARTMENT.DeptID} DEPARTMENT

#### **🔸 SQL Equivalent:**

SELECT E.Name, D.DeptName, E.Salary  
FROM EMPLOYEE E  
JOIN DEPARTMENT D  
ON E.DeptID \= D.DeptID  
WHERE E.Salary \> 50000;

---

### **🟡 3\. Equi Join**

#### **🔸 Definition:**

An Equi Join is a special case of conditional join where the condition involves only equality (=) between attributes of both relations.

#### **🔸 Example:**  EMPLOYEE ⋈\_{EMPLOYEE.DeptID \= DEPARTMENT.DeptID} DEPARTMENT

####   This returns all matching rows where the DeptID is the same in both tables.

#### **🔸 SQL Equivalent:**

SELECT \*  
FROM EMPLOYEE E, DEPARTMENT D  
WHERE E.DeptID \= D.DeptID;

---

### **🔵 4\. Natural Join**

#### **🔸 Definition:**

A Natural Join automatically joins two relations based on common attribute names and types, and removes duplicate columns in the result.  
 It is an extension of the equi join.

#### **🔸 Example:**

**STUDENT**

| StudentID | Name |
| ----- | ----- |
| 101 | Anu |
| 102 | Ravi |

**ENROLLMENT**

| StudentID | Course |
| ----- | ----- |
| 101 | DBMS |
| 102 | OS |

 STUDENT ⋈ ENROLLMENT

**Result:**

| StudentID | Name | Course |
| ----- | ----- | ----- |
| 101 | Anu | DBMS |
| 102 | Ravi | OS |

#### **🔸 SQL Equivalent:**

SELECT \* FROM STUDENT NATURAL JOIN ENROLLMENT;

---

### **🔴 5\. Outer Joins**

#### **🔸 Definition:**

Outer joins return all tuples from one or both relations, even if some tuples do not satisfy the join condition.  
 Missing values are represented by NULL.

---

#### **🟢 (a) Left Outer Join**

Returns all tuples from the left relation and the matching tuples from the right relation.  
 If there is no match, the right-side attributes are filled with NULL.

**Relational Algebra:**  
 R ⟕ S

**Example:**

| Emp\_ID | Emp\_Name | Dept\_ID |
| :---- | ----- | ----- |
| 101 | Ram | D1 |
| 102 | Sita | D2 |
| 103 | Raju | D4 |

| Dept\_ID | Dept\_Name |
| ----- | ----- |
| D1 | HR |
| D2 | Finance |
| D3 | IT |

**Output:**

| Emp\_ID | Emp\_Name | Dept\_ID | Dept\_Name |
| ----- | ----- | ----- | ----- |
| 101 | Ram | D1 | HR |
| 102 | Sita | D2 | Finance |
| 103 | Raju | D4 | NULL |

 **SQL Equivalent:**

SELECT \* FROM EMPLOYEE  
LEFT OUTER JOIN DEPARTMENT  
ON EMPLOYEE.DeptID \= DEPARTMENT.DeptID;

---

#### 

#### **🟣 (b) Right Outer Join**

Returns all tuples from the right relation, and matching tuples from the left.  
 If no match exists, the left-side attributes appear as NULL.

**Relational Algebra:**  
 **R ⟖ S**

**SQL Equivalent:**

SELECT \* FROM DEPARTMENT  
RIGHT OUTER JOIN EMPLOYEE  
ON EMPLOYEE.DeptID \= DEPARTMENT.DeptID;

| Emp\_ID | Emp\_Name | Dept\_ID | Dept\_Name |
| ----- | ----- | ----- | ----- |
| 101 | Ram | D1 | HR |
| 102 | Sita | D2 | Finance |
| NULL | NULL | D3 | IT |

---

#### **🟡 (c) Full Outer Join**

Returns all tuples from both relations, placing NULLs for non-matching attributes on either side.

**Relational Algebra:**  
 **R ⟗ S**

| Emp\_ID | Emp\_Name | Dept\_ID | Dept\_Name |
| ----- | ----- | ----- | ----- |
| 101 | Ram | D1 | HR |
| 102 | Sita | D2 | Finance |
| 103 | Raju | D4 | NULL |
| NULL | NULL | D3 | IT |

**SQL Equivalent:**

SELECT \* FROM EMPLOYEE  
FULL OUTER JOIN DEPARTMENT  
ON EMPLOYEE.DeptID \= DEPARTMENT.DeptID;

---

## **🔹 2\. Division (÷)**

### **🔸 Definition:**

The Division operator (÷) is used to find tuples in one relation (dividend) that are related to all tuples in another relation (divisor).  
 It is typically used for queries containing the phrase “for all”.

### **🔸 Notation:**  **R ÷ S**  

* ***R*** **→ Dividend (must have all attributes of *S* and at least one more).**

* ***S*** **→ Divisor.**

---

### **🔸 Example:**

**Student\_Course (Dividend Table):**

| Student\_ID | Course\_ID |
| ----- | ----- |
| 101 | C1 |
| 101 | C2 |
| 102 | C1 |
| 103 | C1 |
| 103 | C2 |

**Course (Divisor Table):**

| Course\_ID |
| ----- |
| C1 |
| C2 |

**Query:**  
 **Find students who are enrolled in all courses listed in the Course table.**

**Relational Algebra Expression:**  
 **Student\_Course ÷ Course**

**Result:**

| Student\_ID |
| ----- |
| 101 |
| 103 |

### **🔸 Explanation:**

* Student 101 is enrolled in both C1 and C2.

* Student 103 is also enrolled in both.

* Student 102 has only C1, so is excluded.

### **🔸 SQL Equivalent (Conceptually):**

(SQL doesn’t have a direct division operator, but it can be represented using `NOT EXISTS` or `GROUP BY`.)

SELECT Student\_ID  
FROM Student\_Course  
GROUP BY Student\_ID  
HAVING COUNT(DISTINCT Course\_ID) \= (SELECT COUNT(\*) FROM Course);

---

## **🧾 Summary of Derived Operators**

| Operator | Symbol | Description | SQL Equivalent |
| ----- | ----- | ----- | ----- |
| Join | ⋈ | Combines tuples from two relations based on a related attribute | `JOIN` |
| Inner Join | ⋈ | Returns only matching tuples | `INNER JOIN` |
| Conditional Join | ⋈ | Join with condition using \>, \<, etc. | `JOIN ... WHERE` |
| Equi Join | ⋈ | Join using equality (=) | `JOIN ON` |
| Natural Join | ⋈ | Join automatically on same attribute names | `NATURAL JOIN` |
| Left Outer Join | ⟕ | Returns all tuples from left table | `LEFT OUTER JOIN` |
| Right Outer Join | ⟖ | Returns all tuples from right table | `RIGHT OUTER JOIN` |
| Full Outer Join | ⟗ | Returns all tuples from both tables | `FULL OUTER JOIN` |
| Division | ÷ | Finds tuples related to *all* values in another relation | `GROUP BY` \+ `HAVING` or `NOT EXISTS` |

---

