# **ðŸ“˜ Derived Operators in Relational Algebra**

---

## **ðŸ”¹ Definition:**

Derived operators are those that can be expressed in terms of basic relational algebra operators such as Selection (Ïƒ), Projection (Ï€), Union (âˆª), Set Difference (âˆ’), Cartesian Product (Ã—), and Rename (Ï).

They are called â€œderivedâ€ because they are constructed from these fundamental operations to perform more complex data retrieval tasks.

### **ðŸ”¸ Common Derived Operators:**

1. **Join Operators (â‹ˆ)**

2. **Division (Ã·)**

---

## **ðŸ”¹ 1\. Join Operators (â‹ˆ)**

### **ðŸ”¸ Definition:**

A Join operation combines tuples from two or more relations based on a common attribute (or condition).  
 It is one of the most important operations in relational algebra since it allows related data stored in different tables to be combined meaningfully**.**

### **ðŸ”¸ General Form:**  **R â‹ˆ\_{condition} S**

###   where *R* and *S* are two relations, and *condition* specifies how tuples are to be matched.

---

### **ðŸ”¸ Types of Joins:**

---

### **ðŸŸ¢ 1\. Inner Join**

#### **ðŸ”¸ Definition:**

The Inner Join retrieves only those tuples that satisfy the join condition â€” i.e., tuples with matching values in both relations.  
 If there is no match between the two tables, that row is excluded from the result.

#### **ðŸ”¸ Notation:**  **R â‹ˆ\_{condition} S** 

#### **ðŸ”¸ Example:**

**EMPLOYEE**

| EmpID | Name | DeptID | Salary |
| ----- | ----- | ----- | ----- |
| 1 | Raj | D1 | 60000 |
| 2 | Neha | D2 | 55000 |
| 3 | Arjun | D3 | 45000 |

**DEPARTMENT**

| DeptID | DeptName |
| ----- | ----- |
| D1 | HR |
| D2 | IT |
| D4 | Finance |

**Relational Algebra Expression:**

 EMPLOYEE â‹ˆ\_{EMPLOYEE.DeptID \= DEPARTMENT.DeptID} DEPARTMENT  
 

**Result:**

| EmpID | Name | DeptID | Salary | DeptName |
| ----- | ----- | ----- | ----- | ----- |
| 1 | Raj | D1 | 60000 | HR |
| 2 | Neha | D2 | 55000 | IT |

#### 

#### 

#### **ðŸ”¸ SQL Equivalent:**

SELECT E.EmpID, E.Name, E.Salary, D.DeptName  
FROM EMPLOYEE E  
INNER JOIN DEPARTMENT D  
ON E.DeptID \= D.DeptID;

---

### **ðŸŸ£ 2\. Conditional Join**

#### **ðŸ”¸ Definition:**

A Conditional Join is an inner join where the condition can include comparison operators such as `=`, `>`, `<`, `>=`, or `<=`.  
 It retrieves tuples that satisfy the given condition between the two relations.

#### **ðŸ”¸ Example:**

Retrieve employees whose salary is greater than â‚¹50,000 and join with department details.

 EMPLOYEE â‹ˆ\_{Salary \> 50000 \\text{ AND } EMPLOYEE.DeptID \= DEPARTMENT.DeptID} DEPARTMENT

#### **ðŸ”¸ SQL Equivalent:**

SELECT E.Name, D.DeptName, E.Salary  
FROM EMPLOYEE E  
JOIN DEPARTMENT D  
ON E.DeptID \= D.DeptID  
WHERE E.Salary \> 50000;

---

### **ðŸŸ¡ 3\. Equi Join**

#### **ðŸ”¸ Definition:**

An Equi Join is a special case of conditional join where the condition involves only equality (=) between attributes of both relations.

#### **ðŸ”¸ Example:**  EMPLOYEE â‹ˆ\_{EMPLOYEE.DeptID \= DEPARTMENT.DeptID} DEPARTMENT

####   This returns all matching rows where the DeptID is the same in both tables.

#### **ðŸ”¸ SQL Equivalent:**

SELECT \*  
FROM EMPLOYEE E, DEPARTMENT D  
WHERE E.DeptID \= D.DeptID;

---

### **ðŸ”µ 4\. Natural Join**

#### **ðŸ”¸ Definition:**

A Natural Join automatically joins two relations based on common attribute names and types, and removes duplicate columns in the result.  
 It is an extension of the equi join.

#### **ðŸ”¸ Example:**

**STUDENT**

| StudentID | Name |
| ----- | ----- |
| 101 | Anu |
| 102 | Ravi |

**ENROLLMENT**

| StudentID | Course |
| ----- | ----- |
| 101 | DBMS |
| 102 | OS |

 STUDENT â‹ˆ ENROLLMENT

**Result:**

| StudentID | Name | Course |
| ----- | ----- | ----- |
| 101 | Anu | DBMS |
| 102 | Ravi | OS |

#### **ðŸ”¸ SQL Equivalent:**

SELECT \* FROM STUDENT NATURAL JOIN ENROLLMENT;

---

### **ðŸ”´ 5\. Outer Joins**

#### **ðŸ”¸ Definition:**

Outer joins return all tuples from one or both relations, even if some tuples do not satisfy the join condition.  
 Missing values are represented by NULL.

---

#### **ðŸŸ¢ (a) Left Outer Join**

Returns all tuples from the left relation and the matching tuples from the right relation.  
 If there is no match, the right-side attributes are filled with NULL.

**Relational Algebra:**  
 R âŸ• S

**Example:**

| Emp\_ID | Emp\_Name | Dept\_ID |
| :---- | ----- | ----- |
| 101 | Ram | D1 |
| 102 | Sita | D2 |
| 103 | Raju | D4 |

| Dept\_ID | Dept\_Name |
| ----- | ----- |
| D1 | HR |
| D2 | Finance |
| D3 | IT |

**Output:**

| Emp\_ID | Emp\_Name | Dept\_ID | Dept\_Name |
| ----- | ----- | ----- | ----- |
| 101 | Ram | D1 | HR |
| 102 | Sita | D2 | Finance |
| 103 | Raju | D4 | NULL |

 **SQL Equivalent:**

SELECT \* FROM EMPLOYEE  
LEFT OUTER JOIN DEPARTMENT  
ON EMPLOYEE.DeptID \= DEPARTMENT.DeptID;

---

#### 

#### **ðŸŸ£ (b) Right Outer Join**

Returns all tuples from the right relation, and matching tuples from the left.  
 If no match exists, the left-side attributes appear as NULL.

**Relational Algebra:**  
 **R âŸ– S**

**SQL Equivalent:**

SELECT \* FROM DEPARTMENT  
RIGHT OUTER JOIN EMPLOYEE  
ON EMPLOYEE.DeptID \= DEPARTMENT.DeptID;

| Emp\_ID | Emp\_Name | Dept\_ID | Dept\_Name |
| ----- | ----- | ----- | ----- |
| 101 | Ram | D1 | HR |
| 102 | Sita | D2 | Finance |
| NULL | NULL | D3 | IT |

---

#### **ðŸŸ¡ (c) Full Outer Join**

Returns all tuples from both relations, placing NULLs for non-matching attributes on either side.

**Relational Algebra:**  
 **R âŸ— S**

| Emp\_ID | Emp\_Name | Dept\_ID | Dept\_Name |
| ----- | ----- | ----- | ----- |
| 101 | Ram | D1 | HR |
| 102 | Sita | D2 | Finance |
| 103 | Raju | D4 | NULL |
| NULL | NULL | D3 | IT |

**SQL Equivalent:**

SELECT \* FROM EMPLOYEE  
FULL OUTER JOIN DEPARTMENT  
ON EMPLOYEE.DeptID \= DEPARTMENT.DeptID;

---

## **ðŸ”¹ 2\. Division (Ã·)**

### **ðŸ”¸ Definition:**

The Division operator (Ã·) is used to find tuples in one relation (dividend) that are related to all tuples in another relation (divisor).  
 It is typically used for queries containing the phrase â€œfor allâ€.

### **ðŸ”¸ Notation:**  **R Ã· S**  

* ***R*** **â†’ Dividend (must have all attributes of *S* and at least one more).**

* ***S*** **â†’ Divisor.**

---

### **ðŸ”¸ Example:**

**Student\_Course (Dividend Table):**

| Student\_ID | Course\_ID |
| ----- | ----- |
| 101 | C1 |
| 101 | C2 |
| 102 | C1 |
| 103 | C1 |
| 103 | C2 |

**Course (Divisor Table):**

| Course\_ID |
| ----- |
| C1 |
| C2 |

**Query:**  
 **Find students who are enrolled in all courses listed in the Course table.**

**Relational Algebra Expression:**  
 **Student\_Course Ã· Course**

**Result:**

| Student\_ID |
| ----- |
| 101 |
| 103 |

### **ðŸ”¸ Explanation:**

* Student 101 is enrolled in both C1 and C2.

* Student 103 is also enrolled in both.

* Student 102 has only C1, so is excluded.

### **ðŸ”¸ SQL Equivalent (Conceptually):**

(SQL doesnâ€™t have a direct division operator, but it can be represented using `NOT EXISTS` or `GROUP BY`.)

SELECT Student\_ID  
FROM Student\_Course  
GROUP BY Student\_ID  
HAVING COUNT(DISTINCT Course\_ID) \= (SELECT COUNT(\*) FROM Course);

---

## **ðŸ§¾ Summary of Derived Operators**

| Operator | Symbol | Description | SQL Equivalent |
| ----- | ----- | ----- | ----- |
| Join | â‹ˆ | Combines tuples from two relations based on a related attribute | `JOIN` |
| Inner Join | â‹ˆ | Returns only matching tuples | `INNER JOIN` |
| Conditional Join | â‹ˆ | Join with condition using \>, \<, etc. | `JOIN ... WHERE` |
| Equi Join | â‹ˆ | Join using equality (=) | `JOIN ON` |
| Natural Join | â‹ˆ | Join automatically on same attribute names | `NATURAL JOIN` |
| Left Outer Join | âŸ• | Returns all tuples from left table | `LEFT OUTER JOIN` |
| Right Outer Join | âŸ– | Returns all tuples from right table | `RIGHT OUTER JOIN` |
| Full Outer Join | âŸ— | Returns all tuples from both tables | `FULL OUTER JOIN` |
| Division | Ã· | Finds tuples related to *all* values in another relation | `GROUP BY` \+ `HAVING` or `NOT EXISTS` |

---

